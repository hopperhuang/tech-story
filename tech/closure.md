#谈谈闭包

闭包是js中很重要的一个特性，很多朋友在学习js的时候，往往会对这个知识点产生迷惑。今天，我们就来谈谈这个容易令人产生迷惑的知识点。

在谈闭包之前，我们首先需要了解一样东西，就是函数的作用域。在js中，内层函数可以访问外层函数。当然，最外层的函数当然是global和window对象，任何函数都可以访问这两个对象。

通过下面的代码，我们来展示一下作用域的访问：

```

var a = 1;

function Outside(){
  console.log(a);
//这里我们不要用a这个变量了，不然会引起hosting；
//先引用后赋值的写法并不是好的实践。
var b = 2;
  function Inside(){
    console.log(b);
  }
  Inside();

}

Outside();
```

在node中执行上面的函数，可以看到终端输出1和2。外层的Outside函数可以访问全局作用域，里层的Inside函数可以访问外层Outside函数的作用域。这就是js中作域域的机制。

里层作用域可以访问外层作用域，要是想要在外层作用域访问外层作用域，是否有方法实现呢?这时，就要用到闭包了。我觉得闭包这个名字定义的挺好的。闭包———封闭的包裹，引用到作用域中，就是js的作用域机制，函数运行完之后，js的垃圾回收机制就回收函数的作用域，就像把作用域这个包裹封闭起来一样。闭包方法，就是访问这个被封闭了的作用域的方法。

那么怎样使用这个方法呢？我们可以把访问闭包的“钥匙”返回到外层作用域中，同时，这个钥匙又保留着对包含它的作用域访问的权力，这样，我们通过这条“钥匙”就可以访问到包含他的作用域。

通过以下的代码，我们展示一下闭包的作用：

```

function makeObject(){
  var a = 1;
  return {
    a:a,
    getA:function(){
      return a;
    },
    addA:function(){
      a++;
    }
  }
}

var o = makeObject();
console.log(o.a); //输出1
o.addA(); 
console.log(o.a);//输出1
console.log(o.getA());//输出2

```

在上面的代码里面，有两处利用了闭包。就是o.getA和o.addA这两个方法。可能有的朋友会疑问，为什么o.addA()方法执行后，o.a还是输出1，而o.getA却是输出2呢？

闭包是，对象对一个封闭了的作用域引用的能力。但是我们仔细来看看o对象中,o的a属性被赋值为1，a属性被保存到o对象中，所以访问o.a时，我们可以在o对象中获取a，并不需要访问外层作用域makeObject函数中的a，所以这个并不闭包，所以addA方法增加的a与o.a属性无关。addA方法、和getA方法中的a，则时闭包方法的体现，这两个方法可以引用makeObject方法中的a，addA增加的时makeObject函数中的a，getA返回的时makeObject函数中的a。

上面的例子说明了闭包的用法，也说明了利用闭包方法时，一定要生成的时引用。

我们将上面的例子改一下：

```

function makeObject(){
  var a = [1];
  return {
    a:a,
    getA:function(){
      return a;
    },
    push:function(){
      a.push(1);
    }
  }
}

var o = makeObject();
console.log(o.a); //输出[1]
o.push();
console.log(o.a);//输出[1,1];
```

这时候，o.a就是对makeObject 里面a数组的引用，我们这里既利用了js储存数组和对象的特性，也利用了闭包方法。

在看看下面的例子。

我们想在for循环结束1秒后，在控制台打印出每一个a;想当然的我们就会这样写。

```

for (var a = 0; a <5; a++){
  setTimeout(function(){console.log(a),1000);
}
```

在终端看一下，打印出来的全是5。
很奇怪，同时也是很显而易见的。函数引用的时a对象，这个a对象是全局作用域中的a对象（因为js中没有块级作用域），但是在打印a对象时，a早就增加为5，所以打印出来的每一个a都是5。那么怎么办呢？？我们想要输出的是0、1、2、3、4。这是我们可以利用闭包。将代码改写成如下：

```

for (var a = 0; a <5; a++){
  (function(){
    var i = a;
    setTimeout(function(){
      console.log(i);
    },1000)
  })();
}
```

在终端一看，打印策划里的是0、1、2、3、4。我们看看是怎么实现的。在自执行函数中，我们将a的值，赋予给i，所以在setTimeout中，i的值，是对自执行函数中的i的引用，所以，输出的实际是自执行函数中的i，而i又分别为每一个a，所以就可以得到我们想要的效果。

写出上面错误的范例，往往是因为我们对js的了解不够，js中，并没有块级作用域。所以错误示范中，一定是误以为输出的a会是循环中的每一个a。解决这个问题，我们可以用闭包方法，当然es6也支持let语句创建块级作用域。

```

for (let a = 0; a <5; a++){
  setTimeout(function(){
     console.log(a);
  },1000);
}
```

上面代码也能实现相同的效果。

闭包虽好，但是切忌滥用！！一般情况下，函数执行完之后，js的垃圾回收机制就会在内存中将函数的作用域回收。但是，如果也个函数的作用域存在被引用的情况，js就不会回收这个函数的作用域，作用域会一直存在域内存当中。过度使用闭包，就会引起大量内存被占用，无法回收的情况。所以，切忌滥用闭包！！
